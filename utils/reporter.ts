import { JobProcessingResult } from '../agent/types.js';
import * as fs from 'fs/promises';
import * as path from 'path';

export class JobReporter {
  private results: JobProcessingResult[] = [];
  private reportDir: string;

  constructor(reportDir = './reports') {
    this.reportDir = reportDir;
  }

  addResult(result: JobProcessingResult): void {
    this.results.push(result);
  }

  async generateReport(): Promise<string> {
    // Ensure report directory exists
    await this.ensureReportDir();

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const reportFileName = `job-application-report-${timestamp}.md`;
    const reportPath = path.join(this.reportDir, reportFileName);

    const markdownContent = this.generateMarkdownContent();
    
    await fs.writeFile(reportPath, markdownContent, 'utf-8');
    console.log(`üìä Report generated: ${reportPath}`);
    
    return reportPath;
  }

  private async ensureReportDir(): Promise<void> {
    try {
      await fs.access(this.reportDir);
    } catch {
      await fs.mkdir(this.reportDir, { recursive: true });
    }
  }

  private generateMarkdownContent(): string {
    const totalJobs = this.results.length;
    const successfulJobs = this.results.filter(r => r.status === 'success').length;
    const failedJobs = this.results.filter(r => r.status === 'failed').length;
    const skippedJobs = this.results.filter(r => r.status === 'skipped').length;
    const errorJobs = this.results.filter(r => r.status === 'error').length;
    const successRate = totalJobs > 0 ? Math.round((successfulJobs / totalJobs) * 100) : 0;
    
    const totalProcessingTime = this.results.reduce((sum, r) => sum + r.processingTimeMs, 0);
    const avgProcessingTime = totalJobs > 0 ? Math.round(totalProcessingTime / totalJobs) : 0;

    const reportDate = new Date().toLocaleDateString();
    const reportTime = new Date().toLocaleTimeString();

    const markdown = `# Job Application Report

**Generated on:** ${reportDate} at ${reportTime}

## Summary

- **Total Jobs Processed:** ${totalJobs}
- **Successful Applications:** ${successfulJobs}
- **Failed Applications:** ${failedJobs}
- **Skipped Jobs:** ${skippedJobs}
- **Error Count:** ${errorJobs}
- **Success Rate:** ${successRate}%
- **Total Processing Time:** ${this.formatDuration(totalProcessingTime)}
- **Average Time per Job:** ${this.formatDuration(avgProcessingTime)}

## Status Distribution

\`\`\`
‚úÖ Success: ${successfulJobs} (${Math.round((successfulJobs/totalJobs)*100)}%)
‚ùå Failed:  ${failedJobs} (${Math.round((failedJobs/totalJobs)*100)}%)
‚è≠Ô∏è Skipped: ${skippedJobs} (${Math.round((skippedJobs/totalJobs)*100)}%)
üö´ Error:   ${errorJobs} (${Math.round((errorJobs/totalJobs)*100)}%)
\`\`\`

## Detailed Results

| Job Name | Company | Status | Processing Time | Fields Filled | Screenshot | Description |
|----------|---------|---------|----------------|---------------|------------|-------------|
${this.generateTableRows()}

## Successful Applications

${this.generateSuccessSection()}

## Failed Applications

${this.generateFailedSection()}

## Error Details

${this.generateErrorSection()}

## Recommendations

${this.generateRecommendations()}

---
*Report generated by Job Applier Stagehand*
`;

    return markdown;
  }

  private generateTableRows(): string {
    return this.results.map(result => {
      const company = this.extractCompanyFromJobName(result.jobName);
      const statusEmoji = this.getStatusEmoji(result.status);
      const processingTime = this.formatDuration(result.processingTimeMs);
      const fieldsFilled = result.fieldsFilled.join(', ') || 'None';
      const screenshot = result.imageOfLastContact ? `[Screenshot](${result.imageOfLastContact})` : 'No screenshot';
      const description = result.description.replace(/\n/g, ' ').substring(0, 100) + '...';
      
      return `| ${result.jobName} | ${company} | ${statusEmoji} ${result.status} | ${processingTime} | ${fieldsFilled} | ${screenshot} | ${description} |`;
    }).join('\n');
  }

  private generateSuccessSection(): string {
    const successfulJobs = this.results.filter(r => r.status === 'success');
    
    if (successfulJobs.length === 0) {
      return '> No successful applications in this session.';
    }

    return successfulJobs.map(job => `
### ‚úÖ ${job.jobName}

- **Link:** [${job.jobLink}](${job.jobLink})
- **Processing Time:** ${this.formatDuration(job.processingTimeMs)}
- **Fields Filled:** ${job.fieldsFilled.join(', ') || 'None specified'}
- **Success Message:** ${job.successMessage || 'Application completed successfully'}
${job.imageOfLastContact ? `- **Screenshot:** ![Last Contact](${job.imageOfLastContact})` : ''}
`).join('\n');
  }

  private generateFailedSection(): string {
    const failedJobs = this.results.filter(r => r.status === 'failed');
    
    if (failedJobs.length === 0) {
      return '> No failed applications in this session.';
    }

    return failedJobs.map(job => `
### ‚ùå ${job.jobName}

- **Link:** [${job.jobLink}](${job.jobLink})
- **Processing Time:** ${this.formatDuration(job.processingTimeMs)}
- **Error:** ${job.errorMessage || 'No specific error message'}
- **Description:** ${job.description}
${job.imageOfLastContact ? `- **Screenshot:** ![Error Screenshot](${job.imageOfLastContact})` : ''}
`).join('\n');
  }

  private generateErrorSection(): string {
    const errorJobs = this.results.filter(r => r.status === 'error');
    
    if (errorJobs.length === 0) {
      return '> No error cases in this session.';
    }

    return errorJobs.map(job => `
### üö´ ${job.jobName}

- **Link:** [${job.jobLink}](${job.jobLink})
- **Error:** ${job.errorMessage || 'Unexpected error occurred'}
- **Description:** ${job.description}
`).join('\n');
  }

  private generateRecommendations(): string {
    const failedJobs = this.results.filter(r => r.status === 'failed' || r.status === 'error');
    const commonErrors = this.analyzeCommonErrors();
    
    let recommendations: string[] = [];

    if (failedJobs.length > 0) {
      recommendations.push(`- Review failed applications (${failedJobs.length} total) and retry manually if needed`);
    }

    if (commonErrors.signInErrors > 2) {
      recommendations.push(`- Consider updating sign-in credentials (${commonErrors.signInErrors} sign-in failures detected)`);
    }

    if (commonErrors.formErrors > 2) {
      recommendations.push(`- Review form filling logic (${commonErrors.formErrors} form errors detected)`);
    }

    if (commonErrors.uploadErrors > 2) {
      recommendations.push(`- Check resume file path and format (${commonErrors.uploadErrors} upload errors detected)`);
    }

    const avgTime = this.results.reduce((sum, r) => sum + r.processingTimeMs, 0) / this.results.length;
    if (avgTime > 60000) { // More than 1 minute per job
      recommendations.push('- Consider optimizing processing time (currently averaging over 1 minute per job)');
    }

    return recommendations.length > 0 
      ? recommendations.map(rec => rec).join('\n')
      : '> No specific recommendations at this time. Great job! üéâ';
  }

  private analyzeCommonErrors(): { signInErrors: number; formErrors: number; uploadErrors: number } {
    let signInErrors = 0;
    let formErrors = 0;
    let uploadErrors = 0;

    for (const result of this.results) {
      if (result.errorMessage) {
        const error = result.errorMessage.toLowerCase();
        if (error.includes('sign') || error.includes('login') || error.includes('auth')) {
          signInErrors++;
        }
        if (error.includes('form') || error.includes('field') || error.includes('required')) {
          formErrors++;
        }
        if (error.includes('upload') || error.includes('file') || error.includes('resume')) {
          uploadErrors++;
        }
      }
    }

    return { signInErrors, formErrors, uploadErrors };
  }

  private extractCompanyFromJobName(jobName: string): string {
    // Simple extraction - you might want to improve this logic
    const parts = jobName.split(' at ');
    return parts.length > 1 ? parts[parts.length - 1] : 'N/A';
  }

  private getStatusEmoji(status: string): string {
    switch (status) {
      case 'success': return '‚úÖ';
      case 'failed': return '‚ùå';
      case 'skipped': return '‚è≠Ô∏è';
      case 'error': return 'üö´';
      default: return '‚ùì';
    }
  }

  private formatDuration(ms: number): string {
    if (ms < 1000) return `${ms}ms`;
    if (ms < 60000) return `${Math.round(ms / 1000)}s`;
    const minutes = Math.floor(ms / 60000);
    const seconds = Math.round((ms % 60000) / 1000);
    return `${minutes}m ${seconds}s`;
  }

  // Method to get summary stats
  getSummaryStats() {
    const totalJobs = this.results.length;
    const successfulJobs = this.results.filter(r => r.status === 'success').length;
    const failedJobs = this.results.filter(r => r.status === 'failed').length;
    const skippedJobs = this.results.filter(r => r.status === 'skipped').length;
    const errorJobs = this.results.filter(r => r.status === 'error').length;
    const successRate = totalJobs > 0 ? Math.round((successfulJobs / totalJobs) * 100) : 0;
    
    return {
      totalJobs,
      successfulJobs,
      failedJobs,
      skippedJobs,
      errorJobs,
      successRate
    };
  }
}
